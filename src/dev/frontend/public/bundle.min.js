"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../library/core/utils/theme/theme.ts
  var _Theme = class _Theme {
    constructor() {
      /**
       * The colors
       */
      this.colors = {
        selection: "#FF601C",
        primary: "#FF601C",
        secondary: "#0B75F2",
        light: "#FFFFFF",
        dark: "#333333",
        trace: "#1CFFA3",
        info: "#3DB9FE",
        debug: "#E7FF48",
        verbose: "#FF601C",
        warn: "#FED424",
        error: "#FF3F66",
        success: "#4BFE55"
      };
    }
  };
  __name(_Theme, "Theme");
  /**
   * The current theme
   */
  _Theme.current = new _Theme();
  var Theme = _Theme;

  // ../../library/core/utils/logger/logger.base.ts
  var _Logger = class _Logger {
    constructor() {
      /**
       * The amount of indents per level
       */
      this.indentsPerLevel = 4;
    }
    /**
     * Prints a message for the clients to see, except if the type
     * provided is verbose, debug or trace.
     * @param options the options
     * @param data any data
     */
    label(type, label, ...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[${label.substring(0, 1).toUpperCase()}${label.substring(1)}] ${d}` : d, "convert");
      this.perform({ type }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a warning message for the clients to see
     * @param data any data
     */
    success(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Success] ${d} ` : d, "convert");
      this.perform({ type: "success" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a warning message for the clients to see
     * @param data any data
     */
    warn(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Warn] ${d} ` : d, "convert");
      this.perform({ type: "warn" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints an error message for the clients to see
     * @param data any data
     */
    error(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Error] ${d}` : d, "convert");
      this.perform({ type: "error" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message for the clients to see
     * @param data any data
     */
    info(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Info] ${d} ` : d, "convert");
      this.perform({ type: "info" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message when the --verbose, --debug or --trace flag is present,
     * this is the lowest level of debug information.
     * @param data any data
     */
    trace(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Trace] ${d} ` : d, "convert");
      this.perform({ type: "trace" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message when the --verbose or --debug flag is present,
     * this is the default level of debug information.
     * @param data any data
     */
    debug(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Debug] ${d} ` : d, "convert");
      this.perform({ type: "debug" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message when the --verbose flag is present,
     * this is the highest level of debug information.
     * @param data any data
     */
    verbose(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Verbose] ${d} ` : d, "convert");
      this.perform({ type: "verbose" }, ...data.map((v) => convert(v)));
    }
    /**
     * Performs printing the log message
     * @param options options
     * @param data the data
     * @returns 
     */
    perform(options, ...data) {
      let {
        type
      } = options;
      const flags = {
        verbose: ["--verbose"],
        debug: ["--verbose", "--debug"],
        trace: ["--verbose", "--debug", "--trace"],
        info: [],
        warn: [],
        error: [],
        success: []
      }[type];
      if (flags.length && !this.argv.find((v) => flags.includes(v))) {
        return;
      }
      for (const d of data) {
        if (typeof d === "string" || typeof d === "boolean" || typeof d === "number" || typeof d === "bigint" || typeof d === "function" || typeof d === "symbol" || typeof d === "undefined") {
          console.log(`${d} `);
        } else {
          console.log(d);
        }
      }
    }
  };
  __name(_Logger, "Logger");
  var Logger = _Logger;

  // ../../library/core/utils/logger/logger.esm.ts
  var _Logger2 = class _Logger2 extends Logger {
    /**
     * Get the current theme colors
     */
    get colors() {
      return Theme.current.colors;
    }
    /**
     * The process.argv arguments used for this logger
     */
    get argv() {
      return window.location.search.split(/\?|\&/).filter(Boolean).map((v) => `--${v}`);
    }
  };
  __name(_Logger2, "Logger");
  var Logger2 = _Logger2;

  // ../../library/core/utils/reactive/listener.ts
  var _Listener = class _Listener {
    /**
     * Creates a new listener instance.
     * @param {Emitter<Event>} event - The event this listener is attached to.
     * @param {function(arg: Event): void} fire - The callback function to execute when the listener is triggered.
     */
    constructor(event, fire) {
      this.event = event;
      this.fire = fire;
    }
    /**
     * Unsubscribe the listener from the event.
     */
    unsubscribe() {
      this.event.unsubscribe(this);
    }
  };
  __name(_Listener, "Listener");
  var Listener = _Listener;

  // ../../library/core/utils/reactive/emitter.ts
  var _Emitter = class _Emitter {
    constructor() {
      this.listeners = {
        once: [],
        always: []
      };
      /**
       * Listen methods for adding event listeners.
       */
      this.listen = {
        /**
         * Add an event listener that triggers on every event emission.
         * @param {function(arg: Event): void} callback - The callback function to execute on event emission.
         * @returns {Listener<Event>} The listener instance.
         */
        always: (callback) => {
          const listener = new Listener(this, callback);
          this.listeners.always.push(listener);
          return listener;
        },
        /**
         * Add an event listener that triggers only once.
         * @param {function(arg: Event): void} callback - The callback function to execute on event emission.
         * @returns {Listener<Event>} The listener instance.
         */
        once: (callback) => {
          const listener = new Listener(this, callback);
          this.listeners.once.push(listener);
          return listener;
        }
      };
    }
    /**
     * Emit the event, triggering all attached listeners.
     * @param {Event} arg - The argument to pass to the listeners.
     */
    emit(arg) {
      return __async(this, null, function* () {
        const promises = [];
        for (const listener of this.listeners.once) {
          const promise = listener.fire(arg);
          if (promise instanceof Promise) {
            promises.push(promise);
          }
          this.unsubscribe(listener);
        }
        for (const listener of this.listeners.always) {
          const promise = listener.fire(arg);
          if (promise instanceof Promise) {
            promises.push(promise);
          }
        }
        yield Promise.all(promises);
      });
    }
    /**
     * Unsubscribe a listener from the event.
     * @param {Listener<Event>} listener - The listener to unsubscribe.
     */
    unsubscribe(listener) {
      this.listeners.always = this.listeners.always.filter((l) => l !== listener);
      this.listeners.once = this.listeners.once.filter((l) => l !== listener);
    }
  };
  __name(_Emitter, "Emitter");
  var Emitter = _Emitter;

  // ../../library/core/utils/json.ts
  var _JSON = class _JSON {
    // TODO: upgrade that circular works properly,
    // if a node has a .parent, dont remove the .children from the node
    /**
     * The replacer for the JSON.stringify function
     */
    static get replacer() {
      const seen = /* @__PURE__ */ new WeakSet();
      return (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return "circular";
          }
          seen.add(value);
        }
        if (typeof value === "function") {
          if (value.prototype && value.prototype.constructor === value) {
            return `[class ${value.name}]`;
          } else {
            return `[function ${value.name}]`;
          }
        }
        return value;
      };
    }
    /**
     * Deserializes a json string into any object
     * @template T the type of object that is returned
     */
    static get deserialize() {
      return typeof window === "undefined" ? global.JSON.parse : window.JSON.parse;
    }
    /**
     * Serializes any object into a json string
     */
    static get serialize() {
      function serialize(obj, indents, replacer) {
        if (typeof window === "undefined") {
          return global.JSON.stringify(obj, replacer || _JSON.replacer, indents || 4);
        } else {
          return window.JSON.stringify(obj, replacer || _JSON.replacer, indents || 4);
        }
      }
      __name(serialize, "serialize");
      return serialize;
    }
  };
  __name(_JSON, "JSON");
  var JSON = _JSON;

  // ../../library/framework/apps/frontend/socket/socket-client.ts
  var _SocketClient = class _SocketClient {
    /**
     * Initialize the socket client
     */
    static initialize() {
      if (!window.socket) {
        this.socket = new WebSocket("ws://localhost:3000");
        this.socket.addEventListener("open", (event) => {
          console.log("Connected to web socket");
        });
        this.socket.addEventListener("message", (event) => {
          var _a;
          if (event.data === "reload-script") {
            (_a = document.querySelector('body >script[src^="bundle.min.js"]')) == null ? void 0 : _a.remove();
            const script = document.createElement("script");
            script.src = `bundle.min.js?time=${(/* @__PURE__ */ new Date()).getTime()}`;
            script.type = "text/javascript";
            script.defer = true;
            document.body.append(script);
          }
        });
        this.socket.addEventListener("close", (event) => {
          console.log("Disconnected from web socket");
        });
        window.socket = this.socket;
      }
    }
    /**
     * Sends a node to the server
     * @param vnode the vnode
     */
    static sendNode(vnode) {
      if (!this.socket) {
        this.initialize();
      }
      this.socket.send(JSON.serialize(vnode));
    }
    /**
     * Sends a VDOM to the server
     * @param vdom the vdom
     */
    static sendDOM(vdom) {
      if (!this.socket) {
        this.initialize();
      }
      this.socket.send(JSON.serialize(vdom));
    }
  };
  __name(_SocketClient, "SocketClient");
  /**
   * The web socket instance
   */
  _SocketClient.socket = null;
  var SocketClient = _SocketClient;

  // ../../library/framework/apps/frontend/vdom/vnode.ts
  var _VNode = class _VNode {
    /**
     * Creates a new VNode instance.
     * @param options - The options for the VNode.
     */
    constructor(options) {
      this.options = options;
      /**
       * The VNode id
       */
      this.id = ++VDOM.counter;
      /**
       * Filled when the node is a render node within this parent
       */
      this.renderNodeParent = null;
      /**
       * Whether the VNode should be updated
       */
      this.shouldUpdate = false;
      this.options.appendedNodes = options.appendedNodes || [];
      if (this.options.component) {
        this.options.component.emitters.initialization.emit({
          component: this.options.component
        });
      }
    }
    get logger() {
      return new Logger2();
    }
    /**
     * Get or set the HTML tag name of the element.
     */
    get tag() {
      return this.options.tag;
    }
    set tag(tag) {
      this.options.tag = tag;
    }
    /**
     * Get or set the HTML Text element of the vnode.
     */
    get text() {
      return this.options.text;
    }
    set text(text) {
      this.options.text = text;
    }
    /**
     * Get or set the renderNode of the vnode.
     */
    get renderNode() {
      return this.options.renderNode;
    }
    set renderNode(renderNode) {
      this.options.renderNode = renderNode;
    }
    /**
     * Gets the root vnode
     */
    get root() {
      let parent = this.parent;
      while (parent) {
        if (parent.parent) {
          parent = parent.parent;
        } else {
          return parent;
        }
      }
      return null;
    }
    /**
     * Get or set the parent VNode.
     */
    get parent() {
      return this.renderNodeParent || this.options.parent;
    }
    set parent(parent) {
      this.options.parent = parent;
      if (this.options.parent) {
        this.options.parent.rootElement = this.rootElement;
        this.options.rootElement = void 0;
      }
    }
    /**
     * Get or set whether this VNode represents a fragment.
     */
    get isFragment() {
      return this.options.isFragment;
    }
    set isFragment(isFragment) {
      this.options.isFragment = isFragment;
    }
    /**
     * Get or set the component associated with this VNode.
     */
    get component() {
      return this.options.component;
    }
    set component(component) {
      this.options.component = component;
    }
    /**
     * Get or set the intrinsic attributes of the element.
     */
    get attributes() {
      return this.options.attributes;
    }
    set attributes(attributes) {
      this.options.attributes = attributes;
    }
    /**
     * Get or set the children VNodes of this VNode.
     */
    get children() {
      return this.options.children;
    }
    set children(children) {
      this.options.children = children;
    }
    /**
     * Get or set the HTML element or text node associated with this VNode.
     */
    get element() {
      return this.options.element;
    }
    set element(element) {
      this.options.element = element;
    }
    /**
     * Get the root element this VNode is appended to
     */
    get rootElement() {
      let root = this.renderNodeParent || this.parent;
      if (root) {
        while (true) {
          if (root.element) {
            if (root.element instanceof Text) {
              this.logger.verbose({ vnode: this });
              throw Error(`A text element VNode has children.`);
            }
            return root.element;
          }
          const parent = root.renderNodeParent || root.parent;
          if (parent) {
            root = parent;
          } else {
            break;
          }
        }
        return root.options.rootElement;
      }
      return this.options.rootElement;
    }
    set rootElement(rootElement) {
      let root = this.renderNodeParent || this.parent;
      if (root) {
        while (true) {
          if (root.parent) {
            root = root.parent;
          } else {
            break;
          }
        }
        root.options.rootElement = rootElement;
        this.options.rootElement = void 0;
      } else {
        this.options.rootElement = rootElement;
      }
    }
    /**
     * Copies the VNode deeply into another VNode
     */
    copy() {
      let copy = new _VNode(__spreadValues({}, this.options));
      copy = __spreadProps(__spreadValues(__spreadValues({}, copy), this), {
        options: __spreadValues({}, copy.options)
      });
      for (const key of Object.keys(this.options)) {
        if (key === "children") {
          const value = this[key];
          copy[key] = value ? value.map((v) => {
            v.parent = this;
            return v.copy();
          }) : [];
        } else if (key === "component") {
          copy[key] = this[key];
          const value = copy[key];
          if (value) {
            value.vnode = copy;
          }
        } else if (key === "renderNode") {
          const value = this[key];
          if (value) {
            copy[key] = value.copy();
            if (copy[key]) {
              copy[key]["renderNodeParent"] = copy;
            }
          }
        }
      }
      return copy;
    }
  };
  __name(_VNode, "VNode");
  var VNode = _VNode;

  // ../../library/framework/apps/frontend/vdom/vdom.ts
  var _VDOM = class _VDOM {
    /**
     * Mounts the VDOM and adds an instance to the VDOM.instances array
     * @param id the id of the element to mount the VDOM in. (should be unique)
     * @param root the JSX to insert at the root
     */
    constructor(id, root) {
      this.root = root;
      /**
       * The VDOM id
       */
      this.id = ++_VDOM.counter;
      /**
       * Updates all nodes that should be updated by re-mounting them.
       * To prevent errors, you must use the `this.markNodesToBeUpdated` function first.
       * @param previous the previous node
       * @param current the current node
       * @param previousDOM the previous VDOM
       * @param currentDOM the current VDOM
       * @returns true on success
       */
      this.updateNodes = /* @__PURE__ */ __name((previous, current, previousDOM, currentDOM) => {
        if (!previous.rootElement) {
          throw new Error(`Previous has no root element`);
        }
        if (!previous.shouldUpdate || !current.shouldUpdate) {
          let success = true;
          if (previous.component) {
            for (let i = previous.renderNode.children.length - 1; i >= 0; i--) {
              if (!this.updateNodes(previous.renderNode.children[i], current.renderNode.children[i], previousDOM, currentDOM)) {
                success = false;
              }
            }
          } else if (!previous.text) {
            for (let i = previous.children.length - 1; i >= 0; i--) {
              if (!this.updateNodes(previous.children[i], current.children[i], previousDOM, currentDOM)) {
                success = false;
              }
            }
          }
          return success;
        }
        if (previous === previousDOM.root) {
          this.logger.trace(`Updating entire DOM`);
          currentDOM.replaceDOM(previousDOM);
          return true;
        }
        const indices = _VDOM.getRootElementIndices(previous, previous);
        if (current.component) {
          previous.element = void 0;
          previous.text = void 0;
          previous.isFragment = false;
          current.rootElement = previous.rootElement;
          current.parent = previous.parent;
          current.id = previous.id;
          current.component.vnode = previous;
          if (current.renderNode === null) {
            previous.renderNode = null;
            this.logger.trace(`Updating component`, {
              name: current.component.constructor.name,
              current,
              previous
            });
          } else {
            if (previous.component) {
              if (String(previous.component.constructor) === String(current.component.constructor)) {
                current.component.state = _VDOM.deepAssign(current.component.state, previous.component.state);
              }
            }
            previous.component = current.component;
            current.renderNode = current.component.render();
            if (current.renderNode) {
              _VDOM.createElements(current.renderNode, previous.renderNode || null);
              current.renderNode.renderNodeParent = previous;
              previous.renderNode = current.renderNode;
              this.logger.trace(`Updating component`, {
                name: current.component.constructor.name,
                current,
                previous
              });
              _VDOM.mountDOM(previous.renderNode, previous.rootElement, indices[0]);
            }
            previous.component = current.component;
          }
        } else if (current.isFragment) {
          current.text = void 0;
          current.element = void 0;
          current.component = void 0;
          current.renderNode = void 0;
          current.rootElement = previous.rootElement;
          current.parent = previous.parent;
          current.isFragment = true;
          current.id = previous.id;
          this.logger.trace(`Updating fragment`, {
            current,
            previous
          });
          _VDOM.mountDOM(current, previous.rootElement, previous.parent ? previous.parent.children.map((v, i, a) => i >= a.indexOf(previous) ? 0 : _VDOM.getElements(v).length).reduce((x, y) => x + y, 0) : null);
          previous.parent.children = previous.parent.children.map((v) => v === previous ? current : v);
        } else if (current.text) {
          current.element = current.text;
          current.component = void 0;
          current.renderNode = void 0;
          current.rootElement = previous.rootElement;
          current.parent = previous.parent;
          current.isFragment = false;
          current.id = previous.id;
          previous.parent.children = previous.parent.children.map((v) => v === previous ? current : v);
          this.logger.trace(`Updating text`, {
            current,
            previous
          });
          _VDOM.mountDOM(current, previous.rootElement, indices[0]);
        } else if (current.element) {
          current.text = void 0;
          current.component = void 0;
          current.renderNode = void 0;
          current.rootElement = previous.rootElement;
          current.parent = previous.parent;
          current.isFragment = true;
          current.id = previous.id;
          previous.parent.children = previous.parent.children.map((v) => v === previous ? current : v);
          if (previous.attributes && current.attributes !== previous.attributes) {
            previous.attributes = current.attributes;
          }
          if (current.element instanceof Element) {
            _VDOM.setAttributes(current.attributes, current.element);
          }
          this.logger.trace(`Updating element`, {
            currentEl: current.element,
            previousEl: previous.element,
            current,
            previous
          });
          _VDOM.mountDOM(current, previous.rootElement, indices[0]);
        }
        const elementCount = _VDOM.getElements(current).length;
        for (let i = indices.length - 1; i >= 0; i--) {
          const child = previous.rootElement.childNodes[indices[0] + i + elementCount];
          if (child) {
            try {
              child.remove();
            } catch (err) {
              console.log(err);
            }
          }
        }
        current.shouldUpdate = false;
        previous.shouldUpdate = false;
        return true;
      }, "updateNodes");
      const main = document.querySelector(`#${id}`);
      if (!main) {
        throw new Error(`No element with id "${id}" could be found.`);
      }
      root.rootElement = main;
      this.main = main;
      this.setVDOM();
    }
    static get logger() {
      return new Logger2();
    }
    get logger() {
      return _VDOM.logger;
    }
    /**
     * Marks all nodes to be updated or not.
     * @param previous the previous node
     * @param current the current node
     * @returns true if everything has changed inside
     */
    markNodesToBeUpdated(previous, current, previousVDOM, currentVDOM) {
      var _a, _b;
      if (current.text) {
        current.element = current.text;
      }
      if (previous.text) {
        previous.element = previous.text;
      }
      if (!!current.isFragment !== !!previous.isFragment || !!current.text !== !!previous.text || !!current.element !== !!previous.element || !!current.component !== !!previous.component || !!current.renderNode !== !!previous.renderNode || current.children.length !== previous.children.length || current.component && previous.component && (!!previous.renderNode !== !!current.renderNode || ((_a = previous.renderNode) == null ? void 0 : _a.children.length) !== ((_b = current.renderNode) == null ? void 0 : _b.children.length))) {
        previous.shouldUpdate = true;
        current.shouldUpdate = true;
        return true;
      } else {
        if (current.component) {
          if (current.renderNode && previous.renderNode) {
            let shouldUpdate = true;
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            for (let i = 0; i < current.renderNode.children.length; i++) {
              if (!this.markNodesToBeUpdated(previous.renderNode.children[i], current.renderNode.children[i], previousVDOM, currentVDOM)) {
                shouldUpdate = false;
                previous.shouldUpdate = false;
                current.shouldUpdate = false;
              }
            }
            return shouldUpdate;
          } else if (current.renderNode === void 0 || previous.renderNode === void 0) {
            this.logger.verbose({ current, previous });
            throw new Error(`Current or previous was never rendered`);
          } else {
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            return true;
          }
        } else if (current.isFragment) {
          this.logger.verbose("fragment");
          let shouldUpdate = true;
          previous.shouldUpdate = true;
          current.shouldUpdate = true;
          for (let i = 0; i < current.children.length; i++) {
            if (!this.markNodesToBeUpdated(previous.children[i], current.children[i], previousVDOM, currentVDOM)) {
              shouldUpdate = false;
              previous.shouldUpdate = false;
              current.shouldUpdate = false;
            }
          }
          return shouldUpdate;
        } else if (current.text) {
          this.logger.verbose("text");
          if (previous.rootElement) {
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            const values = {
              current: current.text instanceof Text ? current.text.textContent : current.text.outerHTML,
              previous: previous.text instanceof Text ? previous.text.textContent : previous.text.outerHTML
            };
            if (values.current === values.previous) {
              previous.shouldUpdate = false;
              current.shouldUpdate = false;
              return false;
            }
            return true;
          } else {
            this.logger.verbose({ previous, current });
            throw new Error(`Previous has no root element`);
          }
        } else if (current.element) {
          this.logger.verbose("element");
          if (previous.rootElement) {
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            const values = {
              current: current.element instanceof Text ? current.element.textContent : current.element.outerHTML,
              previous: previous.element instanceof Text ? previous.element.textContent : previous.element.outerHTML
            };
            if (values.current === values.previous) {
              previous.shouldUpdate = false;
              current.shouldUpdate = false;
              if (current.attributes !== previous.attributes) {
                previous.attributes = current.attributes;
                if (previous.element instanceof Element) {
                  _VDOM.setAttributes(current.attributes, previous.element);
                }
              }
              return false;
            }
            let shouldUpdate = true;
            for (let i = 0; i < current.children.length; i++) {
              if (!this.markNodesToBeUpdated(previous.children[i], current.children[i], previousVDOM, currentVDOM)) {
                shouldUpdate = false;
                previous.shouldUpdate = false;
                current.shouldUpdate = false;
              }
            }
            return shouldUpdate;
          } else {
            this.logger.verbose({ previous, current });
            throw new Error(`Previous has no root element`);
          }
        } else {
          this.logger.verbose({ invalid: current });
          throw new Error(`Invalid VNode`);
        }
      }
    }
    /**
     * Sets the VDOM and mounts it into the main element
     * @param main the main element
     * @param root the root vnode
     */
    setVDOM() {
      _VDOM.window.VDOMS = _VDOM.window.VDOMS || [];
      const vdoms = _VDOM.window.VDOMS;
      const previous = vdoms.find((v) => v.main === this.main);
      const current = this;
      current.root.rootElement = current.main;
      if (previous) {
        this.logger.verbose(`Updating DOM based on Hot Reload`);
        this.updateDOM(previous, current);
      } else {
        this.logger.verbose(`Initializing DOM`);
        this.initializeDOM();
        vdoms.push(this);
      }
    }
    /**
     * Updates the DOM by comparing the current VDOM to the previous VDOM
     * @param previous the previous vdom
     * @param current the current vdom
     */
    updateDOM(previous, current) {
      console.log({
        previous,
        current
      });
      _VDOM.createElements(current.root, previous.root);
      const div = _VDOM.document.createElement("div");
      _VDOM.mountDOM(current.root, div);
      this.markNodesToBeUpdated(previous.root, current.root, previous, current);
      console.log(previous, current);
      if (!this.updateNodes(previous.root, current.root, previous, current)) {
        this.logger.verbose({ previous, current });
        throw new Error(`Could not update nodes, updating DOM failed.`);
      }
    }
    /**
     * Replaces the content of the main element with the new content
     */
    replaceDOM(previous) {
      this.initializeDOM();
      previous.root = this.root;
    }
    /**
     * Initializes the content of the main element with the new content
     */
    initializeDOM() {
      this.main.innerHTML = "";
      _VDOM.createElements(this.root, null);
      _VDOM.mountDOM(this.root, this.main);
    }
    /**
     * Creates a vnode from deepest nesting until the root of the VDOM (when a JSX element has been created)
     * @param tag the name of the tag, or a `Component` prototype
     * @param attributes the attributes of the JSX element
     * @param children the children that were created with this function before going to this parent node.
     */
    static createNode(tag, attributes, ...children) {
      SocketClient.initialize();
      const processedChildren = [];
      (children || []).forEach(/* @__PURE__ */ __name(function processChild(child) {
        if (Array.isArray(child)) {
          for (const c of child) {
            processChild(c);
          }
        } else {
          if (child instanceof VNode) {
            processedChildren.push(child);
          } else {
            const vnode2 = new VNode({
              text: child instanceof Text ? child : typeof child === "object" ? document.createElement("span") : document.createTextNode(
                typeof child === "string" ? child : String(child)
              ),
              attributes: {},
              children: []
            });
            if (vnode2.text instanceof HTMLElement) {
              vnode2.text.innerHTML = JSON.serialize(child).replace(/\r\n|\r|\n/g, "<br/>").replace(/\s/g, "&nbsp;");
            }
            processedChildren.push(vnode2);
          }
        }
      }, "processChild"));
      this.logger.verbose({
        message: "Create node called",
        tag,
        attributes,
        children,
        processedChildren
      });
      const vnode = new VNode({
        isFragment: typeof tag === "string" ? false : tag.prototype instanceof Component ? false : true,
        tag: typeof tag === "string" ? tag : void 0,
        component: typeof tag === "string" ? void 0 : tag.prototype instanceof Component ? new tag(__spreadProps(__spreadValues({}, attributes || {}), { children: processedChildren })) : void 0,
        attributes: attributes || {},
        children: processedChildren
      });
      this.logger.verbose({
        message: "new VNode",
        vnode
      });
      if (vnode.component) {
        vnode.component.vnode = vnode;
      }
      processedChildren.forEach((v) => {
        v.parent = vnode;
      });
      return vnode;
    }
    /**
     * Deeply assigns objectB by objectA
     * @param objectA the object to assign to
     * @param objectB the object to assign with
     */
    static deepAssign(objectA, objectB) {
      for (const key of Object.keys(objectB)) {
        if (typeof objectA[key] === "object") {
          if (typeof objectB[key] === "object") {
            objectA[key] = this.deepAssign(objectA[key], objectB[key]);
          } else {
            objectA[key] = objectB[key];
          }
        } else {
          objectA[key] = objectB[key];
        }
      }
      return objectA;
    }
    /**
     * Get the elements of a vnode
     * @param vnode the vnode
     * @param elements the elements
     */
    static getElements(vnode, elements = []) {
      if (vnode.component) {
        if (vnode.renderNode) {
          this.getElements(vnode.renderNode, elements);
        } else if (vnode.renderNode === void 0) {
          this.logger.verbose({ vnode, elements });
          throw new Error(`Vnode was never rendered`);
        }
      } else if (vnode.isFragment) {
        for (const child of vnode.children) {
          this.getElements(child, elements);
        }
      } else if (vnode.element) {
        elements.push(vnode.element);
      }
      return elements;
    }
    /**
     * Creates the elements within a root VNode
     * @param vnode the root vnode
     */
    static createElements(vnode, originalNode) {
      var _a;
      if (vnode.component && !vnode.renderNode) {
        this.window.states = this.window.states || [];
        const states = this.window.states;
        const state = states.find((v) => v.constructor === String(vnode.component.constructor));
        const setState = /* @__PURE__ */ __name(() => {
          if (originalNode && originalNode.component) {
            vnode.component.state = __spreadValues({}, this.deepAssign(vnode.component.state, originalNode.component.state));
          }
        }, "setState");
        if (!state) {
          this.window.states.push({
            constructor: String(vnode.component.constructor),
            state: this.deepAssign({}, vnode.component.state)
          });
          setState();
        } else if (JSON.serialize(state.state) !== JSON.serialize(vnode.component.state)) {
          state.state = vnode.component.state;
        } else {
          setState();
        }
        vnode.renderNode = (_a = vnode.component) == null ? void 0 : _a.render();
        if (vnode.renderNode) {
          vnode.renderNode.renderNodeParent = vnode;
          this.createElements(vnode.renderNode, originalNode);
        }
      } else if (!vnode.component) {
        if (vnode.isFragment) {
          for (let i = 0; i < vnode.children.length; i++) {
            this.createElements(vnode.children[i], (originalNode == null ? void 0 : originalNode.children[i]) || null);
          }
        } else if (vnode.text) {
          vnode.element = vnode.text;
        } else if (vnode.tag) {
          vnode.element = this.document.createElement(vnode.tag);
          this.setAttributes(vnode.attributes, vnode.element);
          for (let i = 0; i < vnode.children.length; i++) {
            this.createElements(vnode.children[i], (originalNode == null ? void 0 : originalNode.children[i]) || null);
          }
        } else {
          this.logger.verbose({ vnode });
          throw new Error(`Unknown VNode syntax`);
        }
      }
      return null;
    }
    /**
     * Finds the node index of element within the childNodes of rootElement
     * @param rootElement the root element containing the element
     * @param element the element
     * @returns the index or -1 if not found
     */
    static getNodeIndex(rootElement, element) {
      const children = rootElement.childNodes;
      for (let i = 0; i < children.length; i++) {
        const node = children[i];
        if (node === element) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Gets the element indices within any node
     * @param base 
     * @param current 
     */
    static getRootElementIndices(base, current, indices = []) {
      if (!base.rootElement) {
        this.logger.verbose({ base, current, indices });
        throw new Error(`Base has no root element.`);
      }
      const containingElement = base.rootElement;
      if (current.component) {
        if (current.renderNode === void 0) {
          this.logger.verbose({ base, current, indices });
          throw new Error(`Base has component but it hasn't been rendered yet, so it's not in the DOM.`);
        }
        if (current.renderNode) {
          return this.getRootElementIndices(base, current.renderNode, indices);
        }
      } else if (current.isFragment) {
        for (const child of current.children) {
          this.getRootElementIndices(base, child, indices);
        }
      } else if (current.element) {
        indices.push(this.getNodeIndex(containingElement, current.element));
      } else {
        this.logger.verbose({ base, current, indices });
        throw Error(`Invalid VNode.`);
      }
      return indices;
    }
    /**
     * Updates the DOM based on a changed VDOM node that is a component 
     * @param vnode the vdom
     */
    static rerenderComponent(vnode) {
      var _a, _b;
      if (vnode.element && !((_a = vnode.parent) == null ? void 0 : _a.rootElement)) {
        this.logger.verbose({ vnode });
        throw new Error(`VNode has element but no parent with root element.`);
      }
      if (!vnode.rootElement) {
        this.logger.verbose({ vnode });
        throw new Error(`VNode has no root element.`);
      }
      if (vnode.component) {
        if (!vnode.renderNode) {
          return;
        }
        const indices = this.getRootElementIndices(vnode, vnode);
        const min = indices[0];
        const max = indices[indices.length - 1];
        const element = vnode.rootElement;
        for (let i = max; i >= min; i--) {
          element.removeChild(element.childNodes[i]);
        }
        vnode.renderNode = (_b = vnode.component) == null ? void 0 : _b.render();
        if (vnode.renderNode) {
          vnode.renderNode.renderNodeParent = vnode;
          this.createElements(vnode.renderNode, null);
          const getElements = /* @__PURE__ */ __name((vnode2, elements2 = []) => {
            if (vnode2.component) {
              if (vnode2.renderNode) {
                getElements(vnode2.renderNode, elements2);
              } else if (vnode2.renderNode === void 0) {
                this.logger.verbose({ vnode: vnode2 });
                throw new Error(`VNode has a component, but no renderNode. Try calling \`this.createElements\` first.`);
              }
            } else if (vnode2.isFragment) {
              for (const child of vnode2.children) {
                getElements(child, elements2);
              }
            } else if (vnode2.element) {
              elements2.push(vnode2.element);
              if (!(vnode2.element instanceof Text)) {
                const fillElement = /* @__PURE__ */ __name((element2, vnode3) => {
                  if (vnode3.component) {
                    if (vnode3.renderNode) {
                      fillElement(element2, vnode3.renderNode);
                    } else if (vnode3.renderNode === void 0) {
                      this.logger.verbose({ vnode: vnode3 });
                      throw new Error(`VNode of type component is not rendered`);
                    }
                  } else if (vnode3.isFragment) {
                    for (const child of vnode3.children) {
                      fillElement(element2, child);
                    }
                  } else if (vnode3.element) {
                    if (vnode3.element instanceof Text) {
                      element2.append(vnode3.element);
                    } else {
                      element2.append(vnode3.element);
                      for (const child of vnode3.children) {
                        fillElement(vnode3.element, child);
                      }
                    }
                  }
                }, "fillElement");
                for (const child of vnode2.children) {
                  fillElement(vnode2.element, child);
                }
              }
              this.logger.verbose({ el: vnode2.element, children: vnode2.children });
            } else {
              this.logger.verbose({ vnode: vnode2 });
              throw new Error(`Invalid VNode.`);
            }
            return elements2;
          }, "getElements");
          const elements = getElements(vnode.renderNode);
          for (let i = min; i < elements.length + min; i++) {
            element.insertBefore(elements[i - min], element.childNodes[i]);
          }
        }
      } else {
        this.logger.verbose({ vnode });
        throw new Error(`The rerenderComponent function is only for components.`);
      }
    }
    /**
     * Unmounts a VNode from the DOM
     * @param vnode the vnode
     */
    static unmountDOM(vnode) {
      var _a;
      if (vnode.component) {
        if (vnode.renderNode) {
          this.unmountDOM(vnode.renderNode);
        } else if (vnode.renderNode === void 0) {
          this.logger.verbose({ vnode });
          throw new Error(`VNode was never rendered.`);
        }
      } else if (vnode.isFragment) {
        vnode.children.forEach((c) => this.unmountDOM(c));
      } else if (vnode.element) {
        (_a = vnode.element.parentElement) == null ? void 0 : _a.removeChild(vnode.element);
        vnode.element = null;
      }
    }
    /**
     * Mounts the VDOM into the DOM after creating the elements
     * @param vnode the root vnode
     * @param appendTo the vnode to append everything to, must contain a Element
     * @param type the type of processing
     */
    static mountDOM(vnode, appendTo, index = null, insertions = { count: 0 }) {
      const appendToElement = appendTo instanceof Element ? appendTo : appendTo.element || appendTo.rootElement;
      if (!appendToElement) {
        throw new Error(`No element found to mount the DOM in.`);
      }
      if (!(appendToElement instanceof HTMLElement)) {
        throw new Error(`Append to element is not of type HTMLElement.`);
      }
      if (vnode.component) {
        if (vnode.renderNode) {
          this.mountDOM(vnode.renderNode, appendTo, index, insertions);
        } else if (vnode.renderNode === void 0) {
          this.logger.verbose({ vnode, appendTo });
          throw new Error(`VNode was never rendered`);
        }
      } else if (vnode.isFragment) {
        for (const child of vnode.children) {
          this.mountDOM(child, appendTo, index, insertions);
        }
      } else if (vnode.element) {
        if (index !== null) {
          appendToElement.insertBefore(vnode.element, appendToElement.childNodes.item(index + insertions.count));
          insertions.count++;
        } else {
          appendToElement.append(vnode.element);
        }
        if (!(vnode.element instanceof Text)) {
          for (const child of vnode.children) {
            this.mountDOM(child, vnode.element);
          }
        }
      } else {
        this.logger.verbose({ vnode, appendTo, index, insertions });
        throw new Error(`Invalid VNode object`);
      }
    }
    /**
     * Sets attributes to an element
     * @param attributes the attributes
     * @param element the element
     */
    static setAttributes(attributes, element) {
      for (const name of Object.keys(attributes)) {
        const value = attributes[name];
        const eventHandlers = [
          "onAbort",
          "onAutoComplete",
          "onAutoCompleteError",
          "onBlur",
          "onCancel",
          "onCanPlay",
          "onCanPlayThrough",
          "onChange",
          "onClick",
          "onClose",
          "onContextMenu",
          "onCueChange",
          "onDBLCLick",
          "onDrag",
          "onDragEnd",
          "onDragEnter",
          "onDragLeave",
          "onDragOver",
          "onDragStart",
          "onDrop",
          "onDurationChange",
          "onEmptied",
          "onEnded",
          "onError",
          "onFocus",
          "onInput",
          "onInvalid",
          "onKeyDown",
          "onKeyPress",
          "onKeyUp",
          "onLoad",
          "onLoadedData",
          "onLoadedMetadata",
          "onLoadStart",
          "onMouseDown",
          "onMouseEnter",
          "onMouseLeave",
          "onMouseMove",
          "onMouseOut",
          "onMouseOver",
          "onMouseUp",
          "onMouseDown",
          "onMouseEnter",
          "onMouseLeave",
          "onMouseMove",
          "onMouseOut",
          "onMouseOver",
          "onMouseUp",
          "onMouseWheel",
          "onPause",
          "onPlay",
          "onPlaying",
          "onProgress",
          "onRateChange",
          "onReset",
          "onResize",
          "onScroll",
          "onSeeked",
          "onSeeking",
          "onSelect",
          "onShow",
          "onSort",
          "onStalled",
          "onSubmit",
          "onSuspend",
          "onTimeUpdate",
          "onToggle",
          "onVolumeChange",
          "onWaiting"
        ];
        if (eventHandlers.includes(name)) {
          element.addEventListener(name.replace(/^on/g, "").toLowerCase(), value);
        } else if (typeof value !== "object") {
          element.setAttribute(name, String(value));
        } else {
          this.logger.verbose(`Unhandled attribute "${name}" on type "${element.tagName.toLowerCase()}"`);
        }
      }
    }
  };
  __name(_VDOM, "VDOM");
  /**
   * The counter for ID's
   */
  _VDOM.counter = 0;
  /**
   * The window (either a JSDOM instance in case of Node.JS otherwise the browsers window object)
   */
  _VDOM.window = window || new (__require("jsdom")).JSDOM().window;
  /**
   * The document in the window
   */
  _VDOM.document = _VDOM.window.document;
  var VDOM = _VDOM;

  // ../../library/framework/apps/frontend/components/component/component.ts
  var _Component = class _Component {
    constructor(props) {
      /**
       * The logger
       */
      this.logger = new Logger2();
      /**
       * The component's event emitters, when extending this with your own emitters
       * use the spread syntax ...super.emitters in your object so they keep existing.
       */
      this.emitters = {
        initialization: new Emitter(),
        mounted: new Emitter(),
        // TODO: 
        propsChanged: new Emitter(),
        // TODO: 
        beforeRender: new Emitter(),
        // TODO:
        afterRender: new Emitter(),
        // TODO:
        umounted: new Emitter()
      };
      /**
       * Here you can add your event listeners of `this.emitters`; they will be automatically
       * unsubscribed after the component unmounts. No worries about the cleanup there.
       */
      this.listeners = [];
      /**
       * Event listeners that are there for every component
       */
      this._listeners = [
        this.emitters.umounted.listen.once(() => {
          [...this._listeners, ...this.listeners].forEach((l) => l.unsubscribe());
        })
      ];
      /**
       * Whether or not the state has been initialized
       */
      this._stateInitialized = false;
      /**
       * The internal state of the component
       */
      this._state = {};
      /**
       * Rerenders the entire component in the VDOM, then applies it to the changes to the DOM right after.
       */
      this.rerender = /* @__PURE__ */ __name(() => {
        VDOM.rerenderComponent(this.vnode);
      }, "rerender");
      if (!props.children) {
        throw new Error(`Component props.children is not present`);
      }
      this.props = props;
      this.emitters.initialization.emit({
        component: this
      });
      this.emitters.propsChanged.emit({
        component: this,
        props: this.props
      });
    }
    /**
     * Get or sets the state, if set a deep Proxy is created to
     * automatically call this.rerender() upon any changes anywhere
     * within the state object with infinite depth.
     */
    get state() {
      return this._state;
    }
    set state(state) {
      const deepProxy = /* @__PURE__ */ __name((target, path) => new Proxy(target, {
        get: (obj, prop) => {
          this.logger.verbose("get", path);
          const value = obj[prop];
          if (typeof value === "object" && value !== null) {
            const newPath = [...path, String(prop)];
            return deepProxy(value, newPath);
          }
          return value;
        },
        /**
         * Intercept property assignment
         */
        set: (obj, prop, newValue) => {
          if (obj[prop] === newValue) {
            this.logger.verbose(`set called without any changes`, path);
            return true;
          }
          this.logger.verbose("set", path);
          obj[prop] = newValue;
          this.rerender();
          return true;
        }
      }), "deepProxy");
      this._state = deepProxy(state, []);
      if (!this._stateInitialized) {
        this._stateInitialized = true;
      } else {
        this.rerender();
      }
    }
    /**
     * Gets or sets the child nodes
     */
    get children() {
      return this.props.children || [];
    }
    set children(value) {
      this.props.children = value;
    }
  };
  __name(_Component, "Component");
  var Component = _Component;

  // ../../library/framework/apps/frontend/components/page.ts
  var _Page = class _Page extends Component {
    constructor(props) {
      super(props);
      this.params = {};
    }
  };
  __name(_Page, "Page");
  var Page = _Page;

  // ../../library/framework/apps/frontend/components/router/router.tsx
  var _Router = class _Router extends Component {
    render() {
      return /* @__PURE__ */ VDOM.createNode("div", { id: "router" }, this.children);
    }
  };
  __name(_Router, "Router");
  var Router = _Router;

  // ../../library/framework/apps/frontend/components/router/route.tsx
  var _Route = class _Route extends Component {
    render() {
      if (this.props.path !== window.location.pathname) {
        return null;
      }
      return /* @__PURE__ */ VDOM.createNode("div", null, this.children);
    }
  };
  __name(_Route, "Route");
  var Route = _Route;

  // src/app.tsx
  var _TestComponent = class _TestComponent extends Component {
    render() {
      return /* @__PURE__ */ VDOM.createNode("div", { id: "test-component", style: "background: orange; padding: 5px;" }, /* @__PURE__ */ VDOM.createNode("div", { style: "background: black; color: white;" }, "Test"), new Array(3).fill("").map((v, i) => /* @__PURE__ */ VDOM.createNode(VDOM.createNode, null, "Test components ", i + 1, /* @__PURE__ */ VDOM.createNode("br", null))));
    }
  };
  __name(_TestComponent, "TestComponent");
  var TestComponent = _TestComponent;
  var _HomePage = class _HomePage extends Page {
    render() {
      return /* @__PURE__ */ VDOM.createNode("div", { id: "home", style: {
        background: "red"
      }, onClick: (e) => {
      } }, "homeesssssss", /* @__PURE__ */ VDOM.createNode(TestComponent, null));
    }
  };
  __name(_HomePage, "HomePage");
  var HomePage = _HomePage;
  var _TestPage = class _TestPage extends Page {
    render() {
      return /* @__PURE__ */ VDOM.createNode("div", { id: "test", style: "background: yellow; padding: 5px;" }, "Test pagessaad", /* @__PURE__ */ VDOM.createNode(TestComponent, null));
    }
  };
  __name(_TestPage, "TestPage");
  var TestPage = _TestPage;
  var _A = class _A extends Component {
    constructor(props) {
      super(props);
      this.state = {
        test: 12
      };
    }
    render() {
      return /* @__PURE__ */ VDOM.createNode(VDOM.createNode, null, /* @__PURE__ */ VDOM.createNode("div", { id: this.state.test, onClick: () => {
        this.state.test++;
      } }, this.state.test, /* @__PURE__ */ VDOM.createNode("div", null, "tests"), /* @__PURE__ */ VDOM.createNode("div", null, "tesatta"), /* @__PURE__ */ VDOM.createNode("div", null, "1ss"), /* @__PURE__ */ VDOM.createNode("div", null, "3"), /* @__PURE__ */ VDOM.createNode("div", null, "4"), /* @__PURE__ */ VDOM.createNode("div", null, "gga2b")), /* @__PURE__ */ VDOM.createNode("div", null, "Yoloa"), "Test");
    }
  };
  __name(_A, "A");
  var A = _A;
  new VDOM(
    "main",
    /* @__PURE__ */ VDOM.createNode("div", null, /* @__PURE__ */ VDOM.createNode("div", { style: "background: red; color: white; padding: 5px;" }, /* @__PURE__ */ VDOM.createNode("div", null, "Start of VDOM")), /* @__PURE__ */ VDOM.createNode("div", null, "Tessts"), /* @__PURE__ */ VDOM.createNode(VDOM.createNode, null, /* @__PURE__ */ VDOM.createNode("div", null, "TESsT"), /* @__PURE__ */ VDOM.createNode("div", null, "TESsT"), /* @__PURE__ */ VDOM.createNode("div", null, "TEST"), /* @__PURE__ */ VDOM.createNode("div", null, "TEST"), /* @__PURE__ */ VDOM.createNode("div", null, "TEST"), /* @__PURE__ */ VDOM.createNode(TestPage, null), /* @__PURE__ */ VDOM.createNode(Router, null, /* @__PURE__ */ VDOM.createNode("div", null, "Route tes12sst"), /* @__PURE__ */ VDOM.createNode("div", null, "Route tes12t"), /* @__PURE__ */ VDOM.createNode("div", null, "Route tes12t"), /* @__PURE__ */ VDOM.createNode("div", null, "Route tes12tss"), /* @__PURE__ */ VDOM.createNode("div", null, "Route tes12tss"), /* @__PURE__ */ VDOM.createNode(A, null), "test2s", /* @__PURE__ */ VDOM.createNode(Route, { path: "/test" }, /* @__PURE__ */ VDOM.createNode(TestPage, null), "test", /* @__PURE__ */ VDOM.createNode(TestPage, null)), /* @__PURE__ */ VDOM.createNode(Route, { path: "/test2" }, /* @__PURE__ */ VDOM.createNode(TestPage, null), /* @__PURE__ */ VDOM.createNode(TestPage, null), /* @__PURE__ */ VDOM.createNode(TestPage, null), /* @__PURE__ */ VDOM.createNode(TestPage, null)), /* @__PURE__ */ VDOM.createNode(Route, { path: "/" }, /* @__PURE__ */ VDOM.createNode(HomePage, null)), "test12345678")), /* @__PURE__ */ VDOM.createNode("div", { style: "background: maroon; color: white; padding: 5px;" }, /* @__PURE__ */ VDOM.createNode("div", null, "End of VDOM")))
  );
})();
